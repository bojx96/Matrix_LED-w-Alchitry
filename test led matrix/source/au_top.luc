module au_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output outled,           // to LED strip, Br pin C49 
  ) {
  
  sig rst;                  // reset signal

  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
  }

  led_strip_writer led_strip_1(#PIXEL_COUNT(20), .clk(clk), .rst(rst));

  // init variables
  const COLOURS = {b01, b10, b11, b01}; // G B R G 
  var i;
  var j;
  var p;
  rom_colours COLOUR_ROM;
  const LED_ROW_1_IN = {b01111, b00100, b01111, b11111};
  const LED_ROW_1_OUT = 4x{ 5x{6h0} }
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    usb_tx = usb_rx;        // loop serial port


    // for each colour in guess
    p = 0;
    for (i=0, i < 4; i++) {
      const curr_colour = COLOURS[i];
      const curr_letter = LED_ROW_1_IN[i];
      for (j=0, i < 5, j++) {
        // for each pixel in letter
        const curr_pixel = curr_letter[j];
        if (curr_pixel == 1) {
          // if pixel on, set colour
           curr_pixel = COLOUR_ROM(.selector(curr_colour));
        } else {
          // else, turn off pixel
          curr_pixel = 6h0;
        }
        LED_ROW_1_OUT[p] = curr_pixel;
        p ++
      }
    }

    // LED STRIP 1
    led_strip_1.update = 1;
    led_strip_1.color = LED_ROW_1_OUT[led_strip_1.pixel]; 
    outled=led_strip.led;
  }
 
}